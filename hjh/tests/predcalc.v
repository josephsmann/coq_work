(* exercises from https://coq.inria.fr/tutorial/1-basic-predicate-calculus *)

Variable n : nat.
Hypothesis Pos_n : (gt n 0).
Check gt.
Check (nat -> Prop).
Check (nat -> nat -> Prop).
Check gt n.
Definition double (m : nat) := plus m m.
Compute double 4.
Definition add_n (m:nat) := plus m n.
Compute add_n 1.
Compute n.

(* Hmm, how do sections work? 
   Section Minimal_Logic. 
   End Minimal_Logic. *)

(* admit for temp assume true *)

(* implication is right associative *)

Variables A B C D : Prop.

(*
Goal (A -> B) -> C <-> A -> (B -> C).
admit.
qued.
*)

Goal (A -> B -> C) -> (A -> B) -> A -> C.
intro H.
intros H' HA.
apply H.
(* Goal A is present *)
exact HA.
(* We get B if we have A, so A becomes a goal again *)
apply H'.
(* assumption looks through available ones *)
assumption.
(* Finally check proof and remember result *)
Qed.

(* Use the power of the ide *)
Lemma distr_impl : (A -> B -> C) -> 
(A -> B) -> A -> C.
intros.
(* OK, this is cool, use tacticals (named 
as in functionals?)
 T1 ; T2 (read T1 then T2) applies 
  tactic T1 to the current goal, 
  and then tactic T2 to all the subgoals 
  generated by T1.
 T; [T1 | T2 | ... | Tn] applies tactic T 
  to the current goal, and then tactic T1 
  to the first newly generated subgoal, ..., 
  Tn to the nth. 
*)
apply H; [ assumption | apply H0; assumption ].
Qed.

Lemma distr_impl_2 : (A -> B -> C) -> (A -> B) -> A -> C.
(* Coq seems to undrestand propositional logic *)
auto.
Qed.

Lemma and_commutative_0 : A /\ B /\ C -> B /\ A /\ C.
intro H.
elim H.
intro.
intro.
elim H1.
intros.
split.
exact H2.
split.
exact H0.
exact H3. 
Qed.

Print and_commutative_0.

SearchPattern (nat -> nat -> bool).

Lemma and_commutative_1 : A /\ B /\ C -> B /\ A /\ C.
tauto.
Qed.

Lemma and_commutative : A /\ B /\ C -> B /\ A /\ C.
intro H.
split.
elim H.
intro.
intro.
elim H1.
intros.
exact H2.
admit.
split.
elim H.
intros.
exact H0.
elim H.
intros.
(* and elim will say I can prove the conclusion
if I have A and B available, but I don't have them
yet.  We recast the goal as now being conditional
on the components of the and i.e. H *)
elim H.
(* split goal to get A and B because we need and 
intro *)
split.
elim H1.
exact H1.
exact H0.
Qed.

(* conj is the intro operator, split := apply conj *)
Check conj.

(* A Hint Resolve command registers a lemma as a hint 
  to be used from now on by the auto tactic, whose 
  power may thus be incrementally augmented. *)

Lemma or_commutative : A \/ B -> B \/ A.
intro H.
(* elim does case analysis *)
elim H.
clear H.  (* get rid of H, no longer needed *)
(* subgoal 1 *)
intro HA.
right. (* or intro in right *)
trivial. (* A is an assumption *)
(* subgoal 2,could use auto and let Coq do the work *)
intro HB.
left.
trivial.  (* how powerful is trivial *)
Qed.

Print or_commutative.


Lemma or_case : (A -> C) /\ (B -> C) -> (A \/ B -> C).
tauto.
Qed.

Print or_case.
Check or_case.

(* Like Mizar, tautologies are fully understood? *)
Lemma or_3_commutative : A \/ B \/ C  -> C \/ B \/ A.
tauto.
Qed.

(* show me the proof tree! *)
Print or_3_commutative.

Check or_ind.
(* Curry-Howard: or_ind
     : forall A B P : Prop,
       (A -> P) -> (B -> P) -> A \/ B -> P
I.e. or_ind takes a proof of A->P, a proof of B->P, and
returns a proof of (A \/ B)->P *)

Lemma distr_and : A -> B /\ C -> (A -> B) /\ (A -> C).
tauto.
Qed.

Print distr_and.

Lemma NNPeirce : ~ ~ (((A -> B) -> A) -> A).
tauto.
Qed.

Print NNPeirce.

(* Classical, non-constructive reasoning *)
Require Import Classical.
Lemma Peirce : ((A -> B) -> A) -> A.
try tauto.
Qed.

Print Peirce.








