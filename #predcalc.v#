(* exercises from https://coq.inria.fr/tutorial/1-basic-predicate-calculus *)

Variable n : nat.
Hypothesis Pos_n : (gt n 0).
Check gt.
Check (nat -> Prop).
Check (nat -> nat -> Prop).
Check gt n.
Definition double (m : nat) := plus m m.
Compute double 4.
Definition add_n (m:nat) := plus m n.
Compute add_n 1.
Compute n.

(* Hmm, how do sections work? 
   Section Minimal_Logic. 
   End Minimal_Logic. *)

(* admit for temp assume true *)

(* implication is right associative *)

Variables A B C : Prop.

(*Goal (A -> B) -> C <-> A -> (B -> C).
tauto.
qued.
*)
Goal (A -> B -> C) -> (A -> B) -> A -> C.
intro H.
intros H' HA.
apply H.
(* Goal A is present *)
exact HA.
(* We get B if we have A, so A becomes a goal again *)
apply H'.
(* assumption looks through available ones *)
assumption.
(* Finally check proof and remember result *)
Qed.

(* Use the power of the ide *)
Lemma distr_impl : (A -> B -> C) -> 
(A -> B) -> A -> C.
intros.
(* OK, this is cool, use tacticals (named 
as in functionals?)
 T1 ; T2 (read T1 then T2) applies 
  tactic T1 to the current goal, 
  and then tactic T2 to all the subgoals 
  generated by T1.
 T; [T1 | T2 | ... | Tn] applies tactic T 
  to the current goal, and then tactic T1 
  to the first newly generated subgoal, ..., 
  Tn to the nth. 
*)
apply H; [ assumption | apply H0; assumption ].
Qed.

Lemma distr_impl_2 : (A -> B -> C) -> (A -> B) -> A -> C.
(* Coq seems to undrestand propositional logic *)
auto.
Qed.

Lemma and_commutative2 : (A /\ B) -> B /\ A.
intros.
(* and elim *)
(*elim H.*)
(* split goal because we need and intro *)

elim H.


intros.
split.
exact H1.
exact H0.
Qed.




(* conj is the intro operation, split := apply conj *)
Check conj.

(* A Hint Resolve command registers a lemma as a hint 
  to be used from now on by the auto tactic, whose 
  power may thus be incrementally augmented. *)

Lemma or_commutative : A \/ B -> B \/ A.
intro H.
(* elim does case analysis *)
elim H.
clear H.  (* get rid of H, no longer needed *)
(* subgoal 1 *)
intro HA.
right. (* or intro in right *)
trivial. (* A is an assumption *)
(* subgoal 2 *)
auto. (* let Coq do the work *)
Qed.

(* Like Mizar, tautologies are fully understood? *)
Lemma or_3_commutative : A \/ B \/ C  -> C \/ B \/ A.
tauto.
Qed.

(* show me the proof tree! *)
Print or_3_commutative.

Check or_ind.
(* Curry-Howard: or_ind
     : forall A B P : Prop,
       (A -> P) -> (B -> P) -> A \/ B -> P
I.e. or_ind takes a proof of A->P, a proof of B->P, and
returns a proof of (A \/ B)->P *)

Lemma distr_and : A -> B /\ C -> (A -> B) /\ (A -> C).
tauto.
Qed.

Print distr_and.

Lemma NNPeirce : ~ ~ (((A -> B) -> A) -> A).
tauto.
Qed.

Print NNPeirce.

(* Classical, non-constructive reasoning *)
Require Import Classical.
Lemma Peirce : ((A -> B) -> A) -> A.
try tauto.
Qed.

Print Peirce.








